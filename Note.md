## NestJS

**학습 전 고찰**

- 자유로운 express와는 다르게 규칙을 제공하므로써 express에서 겪었던 어려움들을 해소할 수 있을 것이다.
- express로 백엔드를 구성하며 겪은 어려움
  - express의 자유로움은 진입장벽을 낮추는 장점이 있었다.
  - 하지만, 자유로움은 코드를 작성하며 실수를 유발하는 원인이 되었다.
  - 코드의 구조가 불분명하다보니 중복되는 코드를 작성하는 경우가 발생하기도 했다.
  - 웹 개발 경험이 적고 우유부단한 성격의 나는 어떤 디렉터리의 어떤 파일에 어떤 코드를 작성할지 고민하느라 많은 시간을 고민해야 했다.
- 팀프로젝트 수행시 규칙이 있고 구조적인 Nest가 협업에 있어 생산성을 높이는데 큰 도움이 될 것 같다.
- Nest가 TS를 기반하는 것 또한 매력적으로 느껴진다.
- express에서 TS를 적용하면서 Type을 어떻게 관리할지 interface를 사용해야할지 type을 써야할지, type 선언을 너무 남발하는게 아닌지 하는 고민을 하였다.
- Nest를 학습하면 TS에 대한 학습도 겸사겸사 될 것 같고 위와 같은 고민들에 대한 해답을 얻을 수 있지 않을까싶다.

**1-1. Controllers**

- 모듈: 어플리케이션의 일부분이다. 한 가지의 역할을 하는 어플리케이션이다. 예를 들어 인증을 담당하는 모듈은 user 모듈이 될 것이다.
- app.module: 이는 루트 모듈로 다른 모듈들을 import하여 app을 구성하는 역할을 한다.
- controller
  - url을 가져오고 함수를 실행한다. express의 라우터 같은 존재.
  - 데코레이터로 메서드와 url을 지정한다.
    - ex) @Get(/user), @Post(/user)
    - 데코레이터는 꾸미는 함수나 클래스의 바로위에 존재해야한다.
- 이전에 express에서 controller는 라우팅 보다 req에서 파라미터를 파싱하여 service에 넘겨주는 역할에 초점을 맞췄었다.
- router역할의 코드문법이 조금더 복잡하여 router와 controller를 분리하여 작성하였는데, Nest는 데코레이터를 이용하니 분리하지 않아도 가독성 좋은 코드를 작성 할 수 있는 것 같다.

**1-2. Services**

- Service 계층이 필요한 이유는 뭘까?
  - Nest는 controller를 비즈니스 로직과 분리하기를 원한다. 단지 url을 가져오는 역할을 하도록 한다.

**2-1. more Routes**

- decorater
  - @Param("key"): URL 파라미터를 가져올 때 사용
  - @Query(): Query string을 가져 오기 위해 사용
  - @Body(): Post나 Patch의 바디 데이터를 가져올 떄 사용
- 파라미터 VS Query
  - 파라미터는 특정 id나 이름을 갖는 데이터를 조회할 때 사용
  - 쿼리는 어떤 키워드로 검색하거나 요청시에 필요한 옵션을 전달 할 때 사용
  - 위와 같은 사용이 bestpractice 라고 함... -ㅜ
